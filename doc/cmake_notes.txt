https://cmake.org/cmake/help/book/mastering-cmake/
https://cmake.org/cmake/help/latest/

https://cmake.org/features/
Target-centric approach

Modern CMake allows the build to be specified as a set of targets (executables,
libraries, custom commands). Each target defines what other targets it depends
on directly. CMake then performs the build in the correct order and includes
transitive link targets.

$ apt install cmake

# modern
$ cmake -B build -S src # -DCMAKE_BUILD_TYPE=Debug # Release
$ cmake --build build -j4 # --target clean # -v # verbose

# traditional
$ mkdir build && cd build
$ cmake .. # -DCMAKE_BUILD_TYPE=Debug # Release
$ make -j4 # -s # silent

# staged install
$ cd build
$ make DESTDIR=~/myapp install

# choose compiler using environment variables or command line arguments
$ CC=clang CXX=clang++ cmake -B build -S src
$ cmake -B build -S src -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++


---


Note:

# link with a cmake target.
link_libraries(foo)

# link with a library using -lfoo, e.g., libfoo.so, or, libfoo.a,
link_libraries(-lfoo)
link_directories(../foo)
include_directories(../foo)


---


PUBLIC: 当前目标用，也传播给链接到当前目标的使用者
PRIVATE: 当前目标自己用，不传播给链接到当前目标的使用者
INTERFACE: 当前目标自己不用，传播给链接到当前目标的使用者

foo/CMakeLists.txt
target_link_libraries(foo PUBLIC bar)                # A - 建立依赖关系
target_include_directories(foo PUBLIC /foo/include)  # B - 设置包含目录
target_compile_definitions(foo PUBLIC -DFOO_ENABLED) # C - 设置编译定义

main/CMakeLists.txt
target_link_libraries(main PUBLIC foo)               # 这行触发传播
                                                     # main -> foo -> bar
                                                     # bar通过foo, 被main访问;
                                                     # main是foo的使用者.


---


CMake target-level link:

target_link_libraries(main PUBLIC foo)

. 这是 Modern CMake 的目标级别链接;

. 使用被链接目标中的完整库文件路径 ../foo/libfoo.so.1.2.3 ,
  而非使用 ` -L/path/to `, ` -lfoo ` ,
  这适用于静态库 ` .a `, 或动态共享库 ` .so ` ;

. Propagate transitive usage requirements,
  https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#target-usage-requirements ,
  传递被链接目标中 target_include_directories 命令,
  其中的 PUBLIC, INTERFACE 公开的头文件包含路径,
  自动获得头文件包含路径 include ` -I/header/include/path/ ` ;

. 管理依赖，先构建被链接目标;


---


执行配置:
当修改/增/删 CMakeLists.txt, 增/删 C, C++ 文件或目录结构时;
$ cmake -B build -S . # -DCMAKE_BUILD_TYPE=Debug # Release

执行构建:
当只修改了现有 C, C++ 文件中代码时;
$ cmake --build build -j4 # --target clean # -v # verbose


---


https://cmake.org/cmake/help/latest/command/file.html#filesystem

We do not recommend using GLOB to collect a list of source files from your
source tree. If no CMakeLists.txt file changes when a source is added or removed
then the generated build system cannot know when to ask CMake to regenerate.

CMake 会生成依赖 CMakeLists.txt 的规则，如果 CMakeLists.txt 时间戳变化，会触发重新配置。

1. 不使用GLOB, 明确列出文件名时，如果源代码文件发生了新增/删除，
也需要在 CMakeLists.txt 中修改对应文件名，导致 CMakeLists.txt 时间戳发生变化，
如果此时运行 cmake --build，自动触发重新配置，而不需要手动 cmake -B;

add_executable(myapp
    main.cpp
    foo.cpp
)

2. 使用GLOB的情况，如果源代码文件发生新增/删除，
可能忽略从 CMakeLists.txt 中增删相应文件名，CMakeLists.txt 时间戳不变，
如果此时运行 cmake --build，不会触发重新配置，需要手动 cmake -B;

file(GLOB SOURCES *.c *.cpp)
add_executable(main ${SOURCES})

3. 如果必须使用GLOB，添加CONFIGURE_DEPENDS（CMake 3.12+）
这样不需要再使用 touch 命令修改 CMakeLists.txt 时间戳，或手动运行 CMake -B;

file(GLOB SOURCES CONFIGURE_DEPENDS *.c *.cpp)
add_executable(myapp ${SOURCES})


$ cmake --build build # -v # --target=clean
[ 25%] Building CXX object foo/CMakeFiles/foo.dir/foo.cpp.o
cc1plus: fatal error: /home/ljh/doc/cmake/src/foo/foo.cpp: No such file or directory
compilation terminated.
gmake[2]: *** [foo/CMakeFiles/foo.dir/build.make:79: foo/CMakeFiles/foo.dir/foo.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:129: foo/CMakeFiles/foo.dir/all] Error 2
gmake: *** [Makefile:136: all] Error 2
$
$ touch src/CMakeLists.txt
$
$ cmake --build build # -v # --target=clean
-- Configuring done (0.1s)
-- Generating done (0.0s)
-- Build files have been written to: /home/ljh/doc/cmake/build
[ 25%] Building C object foo/CMakeFiles/foo.dir/foo.c.o
[ 50%] Linking C shared library libfoo.so
[ 50%] Built target foo
[ 75%] Building C object main/CMakeFiles/main.dir/main.c.o
[100%] Linking C executable main
[100%] Built target main
$


---
